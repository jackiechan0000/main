#include <SPI.h>

#define PIN_CS_BARO 10

#define MS5611_CMD_RESET 0x1E
#define MS5611_PROM_READ_BASE 0xA0

uint16_t PROM[8];  // store 8 calibration coefficients

uint16_t readPROM(uint8_t addr) {
  SPI.beginTransaction(SPISettings(250000, MSBFIRST, SPI_MODE0));
  digitalWrite(PIN_CS_BARO, LOW);

  SPI.transfer(addr);
  uint16_t msb = SPI.transfer(0x00);
  uint16_t lsb = SPI.transfer(0x00);

  digitalWrite(PIN_CS_BARO, HIGH);
  SPI.endTransaction();

  return (msb << 8) | lsb;
}

void setup() {
  Serial.begin(115200);
  while (!Serial) { delay(10); }
  delay(500);

  Serial.println("=== Testing MS5611 ===");

  pinMode(PIN_CS_BARO, OUTPUT);
  digitalWrite(PIN_CS_BARO, HIGH);

  SPI.begin();

  // RESET the sensor
  SPI.beginTransaction(SPISettings(250000, MSBFIRST, SPI_MODE0));
  digitalWrite(PIN_CS_BARO, LOW);
  SPI.transfer(MS5611_CMD_RESET);
  digitalWrite(PIN_CS_BARO, HIGH);
  SPI.endTransaction();
  delay(3);

  // Read PROM coefficients
  Serial.println("Reading PROM:");
  for (uint8_t i = 0; i < 8; i++) {
    uint8_t addr = MS5611_PROM_READ_BASE + (i * 2);
    PROM[i] = readPROM(addr);
    Serial.printf("PROM[%d] = 0x%04X\n", i, PROM[i]);
  }
}

// Conversion commands
#define CMD_CONVERT_D1_OSR4096 0x48
#define CMD_CONVERT_D2_OSR4096 0x58
#define CMD_ADC_READ 0x00

uint32_t readADC() {
  SPI.beginTransaction(SPISettings(250000, MSBFIRST, SPI_MODE0));
  digitalWrite(PIN_CS_BARO, LOW);
  SPI.transfer(CMD_ADC_READ);
  uint32_t b1 = SPI.transfer(0);
  uint32_t b2 = SPI.transfer(0);
  uint32_t b3 = SPI.transfer(0);
  digitalWrite(PIN_CS_BARO, HIGH);
  SPI.endTransaction();
  return (b1 << 16) | (b2 << 8) | b3;
}

void loop() {
  // Start pressure conversion
  digitalWrite(PIN_CS_BARO, LOW);
  SPI.transfer(CMD_CONVERT_D1_OSR4096);
  digitalWrite(PIN_CS_BARO, HIGH);
  delay(10); // conversion time

  uint32_t D1 = readADC();  // raw 24-bit pressure

  // Start temperature conversion
  digitalWrite(PIN_CS_BARO, LOW);
  SPI.transfer(CMD_CONVERT_D2_OSR4096);
  digitalWrite(PIN_CS_BARO, HIGH);
  delay(10);

  uint32_t D2 = readADC();  // raw 24-bit temperature

  // First-order temperature calculation
  float dT = (float)D2 - ((float)PROM[5] * 256.0f);
  float TEMP = 2000.0f + dT * (float)PROM[6] / 8388608.0f; // TEMP in 0.01 째C

  // First-order OFF and SENS
  float OFF  = (float)PROM[2] * 65536.0f + ((float)PROM[4] * dT) / 128.0f;
  float SENS = (float)PROM[1] * 32768.0f + ((float)PROM[3] * dT) / 256.0f;

  // Second-order compensation
  float T2 = 0, OFF2 = 0, SENS2 = 0;
  if (TEMP < 2000) { // TEMP < 20 째C
    T2    = (dT * dT) / 2147483648.0f;
    OFF2  = 5.0f * ((TEMP - 2000.0f) * (TEMP - 2000.0f)) / 2.0f;
    SENS2 = 5.0f * ((TEMP - 2000.0f) * (TEMP - 2000.0f)) / 4.0f;

    if (TEMP < -1500) { // TEMP < -15 째C (optional extreme cold)
      OFF2  += 7.0f * ((TEMP + 1500.0f) * (TEMP + 1500.0f));
      SENS2 += 11.0f * ((TEMP + 1500.0f) * (TEMP + 1500.0f)) / 2.0f;
    }
  } else { // TEMP >= 20 째C
    T2    = 0;
    OFF2  = 0;
    SENS2 = 0;
  }

  // Apply second-order compensation
  TEMP -= T2;
  OFF  -= OFF2;
  SENS -= SENS2;

  // Final pressure calculation
  float P = ((D1 * SENS) / 2097152.0f - OFF) / 32768.0f;
  float P_mbar = P / 100.0f;

  Serial.printf("D1=%lu D2=%lu\n", D1, D2);
  Serial.printf("T = %.2f C,  P = %.2f mbar\n", TEMP / 100.0f, P_mbar);

  delay(500);
}
